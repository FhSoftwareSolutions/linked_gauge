---
description: 
globs: 
alwaysApply: true
---
**Project Structure and GitHub Guidance**  

A well-organized project begins with a logical folder and file structure, ensuring clarity and scalability. Start by categorizing your codebase into distinct directories—such as `src/` for core source files, `public/` for static assets, and `tests/` for validation scripts. Adopt consistent naming conventions, like `camelCase` for functions and `kebab-case` for filenames, to maintain uniformity. Modularize components to promote reusability, separating logic, styles, and templates. Avoid monolithic files; instead, break features into focused modules for easier debugging and collaboration.  

For version control, initialize a Git repository with `git init`, stage your files using `git add .`, and commit with a descriptive message like `git commit -m "Initial structure setup"`. Link it to a remote GitHub repository by adding the origin (`git remote add origin [URL]`) and pushing (`git push -u origin main`). Follow semantic branching—prefix branches with `feat/`, `fix/`, or `docs/`—and write meaningful commit messages to track progress. Exclude unnecessary files like environment variables or dependencies by listing them in `.gitignore`.  

Documentation is critical. Your `README.md` should outline the project’s purpose, installation steps, and execution commands. Include examples or screenshots for context. Leverage GitHub’s tools: **Issues** for task tracking, **Projects** for agile workflows, and **Actions** for automation. For larger teams, consider CI/CD pipelines or linters like ESLint to enforce code quality.  

To streamline collaboration, use environment isolation tools like Docker or virtual environments. Regularly sync with remote repositories (`git pull/push`) and review logs (`git log --oneline`) to monitor changes. Whether deploying via Vercel or GitHub Pages, a disciplined structure and versioning workflow will enhance efficiency and reduce friction in development.  

This approach ensures professionalism, adaptability, and seamless teamwork—whether for solo projects or large-scale applications. Adjust the framework based on your stack (e.g., backend services may require `config/` directories, while mobile apps might prioritize platform-specific submodules).